module PrecompileSignatures

using Documenter.Utilities: submodules
using Scratch: get_scratch!

export precompilables, precompile_directives, write_directives

function _is_macro(f::Function)
    text = sprint(show, MIME"text/plain"(), f)
    return contains(text, "macro with")
end

_is_function(x) = x isa Function && !_is_macro(x)

_in_module(f::Function, M::Module) = typeof(f).name.module == M
_in_module(M::Module) = f -> _in_module(f, M)

"Return all functions defined in module `M`."
function _module_functions(M::Module)::Vector{Function}
    allnames = names(M; all=true)
    filter!(x -> !(x in [:eval, :include]), allnames)
    properties = [getproperty(M, name) for name in allnames]
    functions = filter(_is_function, properties)
    filter!(_in_module(M), functions)
    return functions
end

_all_concrete(type::DataType)::Bool = isconcretetype(type)
_all_concrete(types)::Bool = all(map(isconcretetype, types))

_pairs(args...) = vcat(Base.product(args...)...)

function _unpack_union!(x::Union; out=[])
    push!(out, x.a)
    return _unpack_union!(x.b; out)
end
function _unpack_union!(x; out=[])
    push!(out, x)
end

function _split_unions_barrier(pairs)::Set{Tuple}
    filter!(_all_concrete, pairs)
    return Set(pairs)
end

"""
    _split_unions(sig::DataType) -> Set{Tuple}

Return multiple `Tuple`s containing only concrete types for each combination of concrete types that can be found.
"""
function _split_unions(sig::DataType)::Set{Tuple}
    method, types... = sig.parameters
    pairs = _pairs(map(_unpack_union!, types)...)
    return _split_unions_barrier(pairs)
end

"""
Return precompile directives datatypes for signature `sig`.
Each returned `DataType` is ready to be passed to `precompile`.
"""
function _directives_datatypes(sig::DataType, split_unions::Bool)::Vector{DataType}
    method, types... = sig.parameters
    _all_concrete(types) && return [sig]
    concrete_argument_types = if split_unions
        _split_unions(sig)
    else
        return DataType[]
    end
    return DataType[Tuple{method, types...} for types in concrete_argument_types]
end

"Return all method signatures for function `f`."
function _signatures(f::Function)::Vector{DataType}
    sigs = map(methods(f)) do method
        sig = method.sig
        # Ignoring parametric types for now.
        sig isa UnionAll ? nothing : sig
    end
    filter!(!isnothing, sigs)
    return sigs
end

const SUBMODULES_DEFAULT = true
const SPLIT_UNIONS_DEFAULT = true

function _all_submodules(M::Vector{Module})::Vector{Module}
    return collect(Iterators.flatten(map(submodules, M)))
end

"""
    precompilables(M::Vector{Module}; split_unions::Bool=$SPLIT_UNIONS_DEFAULT) -> Vector{DataType}
    precompilables(M::Module; split_unions::Bool=$SPLIT_UNIONS_DEFAULT) -> Vector{DataType}

Return a vector of precompile directives for module `M`.

Keyword arguments:

- `split_unions`:
    Whether to split union types.
    For example, whether to generate two precompile directives for `f(x::Union{Int,Float64})`.
"""
function precompilables(
        M::Vector{Module};
        submodules::Bool=SUBMODULES_DEFAULT,
        split_unions::Bool=SPLIT_UNIONS_DEFAULT
    )::Vector{DataType}
    if submodules
        M = _all_submodules(M)
    end
    types = map(M) do mod
        functions = _module_functions(mod)
        signatures = Iterators.flatten(map(_signatures, functions))
        directives = [_directives_datatypes(sig, split_unions) for sig in signatures]
        return collect(Iterators.flatten(directives))
    end
    return reduce(vcat, types)
end

function precompilables(
        M::Module;
        submodules::Bool=SUBMODULES_DEFAULT,
        split_unions::Bool=SPLIT_UNIONS_DEFAULT
    )::Vector{DataType}
    precompilables([M]; submodules, split_unions)
end

const DEFAULT_WRITE_HEADER = """
    # This file is machine-generated by PrecompileSignatures.jl.
    # Editing it directly is not advised.\n
    """

"""
    write_directives(path, M::AbstractVector{Module}; split_unions::Bool=$SPLIT_UNIONS_DEFAULT, header=\$DEFAULT_WRITE_HEADER)
    write_directives(path, types::Vector{DataType}; header=\$DEFAULT_WRITE_HEADER)

Write precompile directives to file.
"""
function write_directives(path, types::Vector{DataType}; header=DEFAULT_WRITE_HEADER)
    directives = ["precompile($t)" for t in types]
    text = header * join(directives, '\n')
    write(path, text)
    return text
end
function write_directives(
        path,
        M::AbstractVector{Module};
        split_unions::Bool=SPLIT_UNIONS_DEFAULT,
        header=DEFAULT_WRITE_HEADER
    )
    types = precompilables(M; split_unions)
    write_directives(path, types; header)
end
precompile(write_directives, (String, Vector{Module}))

_is_precompile_stage() = ccall(:jl_generating_output, Cint, ()) == 1

"""
    precompile_directives(M::Module)::String

Return the path to generated `precompile` directives.
Do not attempt to be clever and `eval` the directives directly, that will cause "incremental compilation fatally broken" errors.
"""
function precompile_directives(M::Module)::String
    dir = get_scratch!(M, string(M))
    mkpath(dir)
    path = joinpath(dir, "precompile.jl")
    types = precompilables(M)
    write_directives(path, types)
    return path
end

# Include generated `precompile` directives.
if ccall(:jl_generating_output, Cint, ()) == 1
    include(precompile_directives(PrecompileSignatures))
end

end # module
