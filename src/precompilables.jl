function _is_macro(f::Function)
    text = sprint(show, MIME"text/plain"(), f)
    return contains(text, "macro with")
end

_is_function(x) = x isa Function && !_is_macro(x)

_in_module(f::Function, M::Module) = typeof(f).name.module == M
_in_module(M::Module) = f -> _in_module(f, M)

"Return all functions defined in module `M`."
function _module_functions(M::Module) # ::Vector{Function}
    allnames = names(M; all=true)
    filter!(x -> !(x in [:eval, :include]), allnames)
    properties = getproperty.(Ref(M), allnames)
    functions = filter(_is_function, properties)
    # foreach(f -> (@show methods(f)), functions)
    filter!(_in_module(M), functions)
    return functions
end

_all_concrete(type::DataType)::Bool = isconcretetype(type)
_all_concrete(types)::Bool = all(isconcretetype.(types))

_pairs(@nospecialize(args...)) = vcat(Base.product(args...)...)

function _unpack_union!(x::Union; out=[])
    push!(out, x.a)
    return _unpack_union!(x.b; out)
end
function _unpack_union!(x; out=[])
    push!(out, x)
end

"""
    _split_unions(sig::DataType) -> Set{Tuple}

Return multiple `Tuple`s containing only concrete types for each combination of concrete types that can be found.
"""
function _split_unions(sig::DataType)::Set{Tuple}
    method, types... = sig.parameters
    pairs = _pairs(_unpack_union!.(types)...)
    filter!(_all_concrete, pairs)
    return Set(pairs)
end

"""
Return precompile directives datatypes for signature `sig`.
Each returned `DataType` is ready to be passed to `precompile`.
"""
function _directives_datatypes(sig::DataType, split_unions::Bool)::Vector{DataType}
    method, types... = sig.parameters
    _all_concrete(types) && return [sig]
    concrete_argument_types = if split_unions
        _split_unions(sig)
    else
        return DataType[]
    end
    return [Tuple{method, types...} for types in concrete_argument_types]
end

"Return all method signatures for function `f`."
function _signatures(f::Function)::Vector{DataType}
    sigs = map(methods(f)) do method
        sig = method.sig
        # Ignoring parametric types for now.
        sig isa UnionAll ? nothing : sig
    end
    filter!(!isnothing, sigs)
    return sigs
end

const SPLIT_UNION_DEFAULT = true

"""
    precompilables(M::Vector{Module}; split_unions::Bool=$SPLIT_UNION_DEFAULT) -> Vector{DataType}
    precompilables(M::Module; split_unions::Bool=$SPLIT_UNION_DEFAULT) -> Vector{DataType}

Return a vector of precompile directives for module `M`.

Keyword arguments:

- `split_unions`:
    Whether to split union types.
    For example, whether to generate two precompile directives for `f(x::Union{Int,Float64})`.
"""
function precompilables(
        M::Vector{Module};
        split_unions::Bool=SPLIT_UNION_DEFAULT
    )::Vector{DataType}
    types = map(M) do mod
        functions = _module_functions(mod)
        signatures = Iterators.flatten(_signatures.(functions))
        directives = _directives_datatypes.(signatures, split_unions)
        return collect(Iterators.flatten(directives))
    end
    return reduce(vcat, types)
end
precompilables(M::Module; split_unions::Bool=SPLIT_UNION_DEFAULT)::Vector{DataType} = precompilables([M]; split_unions)

const DEFAULT_WRITE_HEADER = """
    # This file is machine-generated by PrecompileSignatures.jl.
    # Editing it directly is not advised.\n
    """

"""
    write_directives(path, M::AbstractVector{Module}; split_unions::Bool=$SPLIT_UNION_DEFAULT, header=\$DEFAULT_WRITE_HEADER)
    write_directives(path, types::Vector{DataType}; header=\$DEFAULT_WRITE_HEADER)

Write precompile directives to file.
"""
function write_directives(path, types::Vector{DataType}; header=DEFAULT_WRITE_HEADER)
    directives = ["precompile($t)" for t in types]
    text = header * join(directives, '\n')
    write(path, text)
    return text
end
function write_directives(
        path,
        M::AbstractVector{Module};
        split_unions::Bool=SPLIT_UNION_DEFAULT,
        header=DEFAULT_WRITE_HEADER
    )
    types = precompilables(M; split_unions)
    write_directives(path, types; header)
end
precompile(write_directives, (String, Vector{Module}))
